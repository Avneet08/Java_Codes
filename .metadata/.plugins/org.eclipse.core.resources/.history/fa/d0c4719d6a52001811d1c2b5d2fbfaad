import java.math.BigInteger;
import java.util.Arrays;
import java.util.Scanner;

public class r4 {
	public static void main(String args[]) {
		try {
			
			Scanner sc = new Scanner(System.in); 
			  int T = sc.nextInt(); 
			  for (int j = 0; j< T; j++) { 
				  int M = sc.nextInt(); 
				  int N = sc.nextInt(); 
				  long arr[] = new long[M]; 
				  long arr2[] = new long[M]; 
				  long sum1=0;
				  long sum2=0;
				  for (int i = 0; i < M; i++) { 
					  arr[i] =sc.nextLong(); 
					  sum1+=arr[i];
					 
					  } 
				  for (int i = 0; i < M; i++) { 
					  arr2[i] = sc.nextLong(); 
					  sum2+=arr2[i];
				  }
				  
				  BigInteger n=fib(sum1, sum2, M, N);
					BigInteger x=new BigInteger("1000000007");
					System.out.println(n.mod(x));
				  }
			
 
		} catch (Exception e) {
			return;
		}
 
	}
 
	public static BigInteger calculatefib(long sum1,long sum2, int M, int N) {
 
	
		BigInteger result=new BigInteger("0");
		long r=sum1*M; long s=sum2*M;
		
				BigInteger[] fib = new BigInteger[1+Math.max(2,N)];
				fib[0]=BigInteger.valueOf(r);
				fib[1]=BigInteger.valueOf(s);
				//System.out.println("sequence is"+fib[0]+" "+fib[1]);
				for(int k=2;k<N;k++) {
					fib[k] = fib[k - 1] .add(fib[k - 2]) ;
				}
				//System.out.println("ssv"+fib[N-1]);
				 result = result .add(fib[N-1]) ;
		
		return result;
		}
	
	 static int MAX = 1000;
	    static BigInteger f[];
	     
	    // Returns n'th fibonacci number using 
	    // table f[]
	    public static BigInteger fib(long sum1,long sum2, int M,int n)
	    {long r=sum1*M; long s=sum2*M;
	        // Base cases
	        if (n == 0)
	            return BigInteger.valueOf(r);
	             
	        if (n == 1 )
	            return (f[n] = BigInteger.valueOf(sum2));
	      
	        // If fib(n) is already computed
	        if (f[n] != BigInteger.valueOf(0))
	            return f[n];
	      
	       /* int k = (n & 1) == 1? (n + 1) / 2
	                            : n / 2;
	      
	        // Applyting above formula [Note value
	        // n&1 is 1 if n is odd, else 0.
	        f[n] = (n & 1) == 1? (fib(k) * fib(k) + 
	                        fib(k - 1) * fib(k - 1))
	                       : (2 * fib(k - 1) + fib(k)) 
	                       * fib(k);*/
	        
	        	if(n%2==0) {
	        		int k=n/2;
	        		f[n]=((f[(int) (k-1)].multiply(BigInteger.valueOf(2)).add(f[k])).multiply(f[k]));
	        	}else {
	        		long k=(n+1)/2;
	        		BigInteger u=f[(int) k].multiply(f[(int) k]);
	        		BigInteger v=f[(int) (k-1)].multiply(f[(int) (k-1)]);
	        		f[n]=u.add(v);
	        	}
	      
	        return f[n];
	    }
	     
	
}
